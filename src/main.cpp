#include "song.h"
#include "retrieve_data.h"
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <cmath>
using namespace std;

float calcDistance(const vector<pair<bool, float>> criteria, Song song);
pair<float, string>* calcHeap(const unordered_map<string, Song>& songs, const int arrSize, const vector<pair<bool, float>> criteria);
void returnPlaylist(const pair<float, string>* heapPtr, const unordered_map<string, Song>& songs);
pair<float, string>* extractMin(pair<float, string>* arr, int size);
int main()
{
    unordered_map<string, Song> songs;
    vector<pair<bool, float>> criteria; //Vector containing whether or not to use the nth criteria, and the value given for said criteria.
    loadSongs(songs);

    songs.at(0).getArtists();
    //Input Interface goes here

    return 0;
}

//Calculates distance based on the criteria specified from the input song and returns a float value.
float calcDistance(const vector<pair<bool, float>> criteria, Song& song)
{
    vector<float> songCrit;
    songCrit.push_back(song.getAcousticness());
    songCrit.push_back(song.getDanceability());
    songCrit.push_back(song.getEnergy());
    songCrit.push_back(song.getInstrumentalness());
    songCrit.push_back(song.getLiveness());
    songCrit.push_back(song.getSpeechiness());
    songCrit.push_back(song.getTempo());
    songCrit.push_back(song.getHappiness());

    float running = 0.0f;
    for(int i = 0; i < criteria.size(); ++i)
    {
        if(criteria[i].first)
            running += pow(criteria[i].second - songCrit[i], 2);
    }
    return pow(running, 0.5);
}
//Extracts the minimum element from the heap
pair<float, string>* extractMin(pair<float, string>* arr, int size)
{
    arr[0] = arr[size-1];
    arr[size-1] = { };
    //Sort array heapwise
    int i = 0;
    while((arr[i].first > arr[2*i+1].first || arr[i].first > arr[2*i+1].first && i < (size-3)/2))
    {
        
        if(arr[2*i+1] > arr[2*i+2])
        {
            float tempFloat = arr[i].first;
            string tempStr = arr[i].second;
            arr[i].first = arr[2*i+2].first;
            arr[i].second = arr[2*i+2].second;
            arr[2*i+2].first = tempFloat;
            arr[2*i+2].second = tempStr;
            
        }
        else
        {
            float tempFloat = arr[i].first;
            string tempStr = arr[i].second;
            arr[i].first = arr[2*i+1].first;
            arr[i].second = arr[2*i+1].second;
            arr[2*i+1].first = tempFloat;
            arr[2*i+1].second = tempStr;
        }
    }
    return arr;
}
//Returns the pointer to an array of pairs of floats for the distance and strings for the IDs with a size specified by the user.
//Keeps only the arrSize smallest heaps, discards the rest.
pair<float, string>* calcHeap(const unordered_map<string, Song>& songs, const int arrSize, const vector<pair<bool, float>> criteria)
{
    pair<float, string>* ptr = new pair<float, string>[arrSize]();
    //if the array is empty, set arr[0] equal to the current song's distance.
    //while not in position, shift around
    //if value tries to shift OOB, drop the value from importance
    
    return ptr;
}
//Prints out the playlist generated by the heap.
void returnPlaylist(const pair<float, string>* heapPtr, const unordered_map<string, Song>& songs)
{

}